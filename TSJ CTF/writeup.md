# Futago

![image](https://user-images.githubusercontent.com/72289126/155925786-be06da71-4129-42fb-9e5c-aa7c6c3815ff.png)

Mô tả trong README :

```
# About this challenge
This challenge consists of 3 stages, each stages has 2 RSA public keys and 2 ciphertexts. The flag of each stage is 1/3 of the flag, so you have to solve all of them to get the flag. You can assume each flag is encrypted using textbook RSA (big endian, no padding).
```

Bạn phải giải quyết cả 3 stage mới có flag

Mỗi stage sẽ là 1 thử thách về RSA gồm 2 public key và 2 ciphertext nhiệm vụ của bạn là tìm lại bản rõ.

Ta có thể hình dung rằng 1 plaintext được mã hoá mới các public key khác nhau :

```
c1 = m^e1 (mod n1)
c2 = m^e2 (mod n2)
```

## Stage 1

![image](https://user-images.githubusercontent.com/72289126/155927114-8ccae4c7-7af3-450f-9976-e7a11c8c9e16.png)

Key structure được encode theo định dạng PEM, do đó bạn hãy viết code hoặc dùng web để decode tìm ra 2 giá trị n,e nhé !

```python
from Crypto.PublicKey import RSA
f = open('./stage1/key1.pub', 'r')
key1 = RSA.importKey(f.read())
n1 = key1.n
print(f'n1 = {n1}')
e1 = key1.e
print(f'e1 = {e1}')
f.close()

f = open('./stage1/key2.pub', 'r')
key2 = RSA.importKey(f.read())
n2 = key2.n
print(f'n2 = {n2}')
e2 = key2.e
print(f'e2 = {e2}')
f.close()
```

output

```commandline
n1 = 5887101892967445512302393009709573362594191034335977702686446653573522418892872143890735426687845254111461265372034642659505979404768275167108077059156417501704452528360772945786530269462798980674453281512004838306417120731049977931108854894021202605713706620706333558929901611233909677933131192370394578396220915603163555229122761382625649400058253040521649841016574945502472294337797942436734503415011093856918753926097754850666003000379227753544168697587806628209389652238467957637121862244135658670762883123986433307510029266263945618368022864702043232089659695092442274431162305578963378970928172616133690545999
e1 = 65537
n2 = 6403313231340794659689139873409787170506493689211116720464778125840199476910540534295356041661136919958283248539391614190824389734906660643211721037342195916739570356795598573982823810056435699092456870152796560286017415801765173932578271589132994270328596862978492140484805831670730300497242877244650630658959325649572245792690956162557918878484168397919090934239342180565647798347742968883736070242819266802029625303831234307502796404780160527159071803562574182274850956187073973689487781601014486531436349498805918821400167903572480970533793567297799849108177872919089652061143315623675824967403600539360008859843
e2 = 65537
```

Đến đây thấy cả 2 số đều lớn và không factor được thì mình thử gcd(n1,n2)

```python
print(math.gcd(n1,n2))
#41254726004593796526068676256254608108957442101318310359221423108335569766223450707225137693237945663372362535148394526896233545486336573956728193370544171424471311260599679489729815212147230713411831178189480253100196767003811583402540128369093340078529064588836956863129633499336900240324868196580378961163
```

OK ta thấy gcd(n1,n2) != 1, do vậy ta có thể đoán `n1 = p*q1`, `n2 = p*q2`
Có p ta dễ dàng tìm được q và giải được stage 1 này 

```python
from Crypto.Util.number import *

f = open('./stage1/flag.txt.key1.enc', 'rb')
c1 = bytes_to_long(f.read())
n1 = 5887101892967445512302393009709573362594191034335977702686446653573522418892872143890735426687845254111461265372034642659505979404768275167108077059156417501704452528360772945786530269462798980674453281512004838306417120731049977931108854894021202605713706620706333558929901611233909677933131192370394578396220915603163555229122761382625649400058253040521649841016574945502472294337797942436734503415011093856918753926097754850666003000379227753544168697587806628209389652238467957637121862244135658670762883123986433307510029266263945618368022864702043232089659695092442274431162305578963378970928172616133690545999
e1 = 65537
p1 = 41254726004593796526068676256254608108957442101318310359221423108335569766223450707225137693237945663372362535148394526896233545486336573956728193370544171424471311260599679489729815212147230713411831178189480253100196767003811583402540128369093340078529064588836956863129633499336900240324868196580378961163
q1 = n1//p1
phi = (p1-1)*(q1-1)
d1 = inverse(e1,phi)
m = pow(c1,d1,n1)
print(long_to_bytes(m)) 
#b'TSJ{just_several_common_rsa_tricks_combined_together_'
```

## Stage 2

Đọc parameters tương tự ở trên ta được : 

```python
n1 = 30035269721416593127976997108554596085782375390936794857329875052762766354084758812560853417353532379872636007573718071377982503106758132681305961506822231704141181160937897670804604383731250264779352385148600358375626145692755279512175567674389618591740853263682762534429181836551083126960941401606432884793025199585396743033121018583823606184938680733357634942216395181516678883263464293131170971753501026604029262872981617492515908740306621976192085519787666873139008260760649355839927037527075282011756425895456229179530723979686074700033067405813230640611146005078556262072420581570011286605428413250889912714459
e1 = 293613
n2 = 30035269721416593127976997108554596085782375390936794857329875052762766354084758812560853417353532379872636007573718071377982503106758132681305961506822231704141181160937897670804604383731250264779352385148600358375626145692755279512175567674389618591740853263682762534429181836551083126960941401606432884793025199585396743033121018583823606184938680733357634942216395181516678883263464293131170971753501026604029262872981617492515908740306621976192085519787666873139008260760649355839927037527075282011756425895456229179530723979686074700033067405813230640611146005078556262072420581570011286605428413250889912714459
e2 = 3981
```

Ta thấy n1 = n2, vậy đây là dạng Common modulus (same n) attack rồi

Đầu tiên dùng thuật toán Euclid mở rộng tìm u,v sao cho `e1 * u + e2 * v = 1`

Lên https://sagecell.sagemath.org/ cho nhanh 

```sage
n1 = 30035269721416593127976997108554596085782375390936794857329875052762766354084758812560853417353532379872636007573718071377982503106758132681305961506822231704141181160937897670804604383731250264779352385148600358375626145692755279512175567674389618591740853263682762534429181836551083126960941401606432884793025199585396743033121018583823606184938680733357634942216395181516678883263464293131170971753501026604029262872981617492515908740306621976192085519787666873139008260760649355839927037527075282011756425895456229179530723979686074700033067405813230640611146005078556262072420581570011286605428413250889912714459
e1 = 293613
n2 = 30035269721416593127976997108554596085782375390936794857329875052762766354084758812560853417353532379872636007573718071377982503106758132681305961506822231704141181160937897670804604383731250264779352385148600358375626145692755279512175567674389618591740853263682762534429181836551083126960941401606432884793025199585396743033121018583823606184938680733357634942216395181516678883263464293131170971753501026604029262872981617492515908740306621976192085519787666873139008260760649355839927037527075282011756425895456229179530723979686074700033067405813230640611146005078556262072420581570011286605428413250889912714459
e2 = 3981
print(xgcd(e1,e2))
#(3, -349, 25740)
```

Output của ta là : `(3, -349, 25740)` => `e1 * -349 + e2 * 25740 = 3`
Ok không bằng 1 như mục đích ban đầu cũng không sao tý ta giải quyết sau :) 

<img src="https://latex.codecogs.com/svg.image?c1^{u}&space;*&space;c2^{v}&space;=&space;m^{e1*u}&space;*&space;m^{e2*v}&space;=&space;&space;m^{e1*u&space;&plus;e2*v}&space;=m^{3}&space;" title="c1^{u} * c2^{v} = m^{e1*u} * m^{e2*v} = m^{e1*u +e2*v} =m^{3} " />

```python
from Crypto.Util.number import *
import gmpy2

n = 30035269721416593127976997108554596085782375390936794857329875052762766354084758812560853417353532379872636007573718071377982503106758132681305961506822231704141181160937897670804604383731250264779352385148600358375626145692755279512175567674389618591740853263682762534429181836551083126960941401606432884793025199585396743033121018583823606184938680733357634942216395181516678883263464293131170971753501026604029262872981617492515908740306621976192085519787666873139008260760649355839927037527075282011756425895456229179530723979686074700033067405813230640611146005078556262072420581570011286605428413250889912714459

f = open('./stage2/flag.txt.key1.enc', 'rb')
c1 = bytes_to_long(f.read())
f.close()

f = open('./stage2/flag.txt.key2.enc', 'rb')
c2 = bytes_to_long(f.read())
f.close()

t,u,v = 3, -349, 25740

m_3 = (pow(c1,u,n) * pow(c2,v,n))%n

print(gmpy2.iroot(m_3,3))
```

Output 

```
(mpz(47687860569438510258672756350354198459249726055392365849017534731461872543071), True)
```

Trả về `True` thì có nghĩa là giá trị trong mpz kia đúng là căn bậc 3 của `m_3`

```python
print(long_to_bytes(47687860569438510258672756350354198459249726055392365849017534731461872543071)) 
#b'in_a_single_guessy(?)_challenge_'
```

## Stage 3

```python
n1 = 225612891097924040706347292537924529130748697814598650779790890321296957687477717412569695768328009713449975967009666897728739592058804927345594604661797805798320309214169550517668137208475071843904537882299585482167565038513108310939720805780339304461071553690155483189411217623168658653984297513568691227493489702035504043460939913284986540798077821986163959026623386252138611094363377701124961846800926711310486987945165331076229592211876939859375144018490447856489757527762378389911481207939664436804078899938906828688591523398747363597695298879921379961097878550014680021403378423799905308848809120405798176353
e1 = 65537
n2 = 225612891097924040706347292537924529130748697814598650779790890321296957687477717412569695768328009713449975967009666897728739592058804927345594604661797805798320309214169550517668137208475071843904537882299585482167565038513108310939720805780339304461071553690155483189411217623168658653984297513568691265159755148954191405071460410083629205595133967069224978599563580256703745535232222292964323590835562142793789416686915496149547981084080783125615742881408395079922620337849148727507795907992405112121391961462894493213328428737417795782345238338628066525116106657456509258570760259889666093973978173599855723931
e2 = 65537
```

Đừng nhìn mấy số đầu mà lại nghĩ là n1 = n2 nha, n1 != n2 đó, nhưng khi thử gcd(n1,n2) = 1

Nhưng mà tại sao lại "na ná" giống nhau như này ? Ta có thể hình dung được như sau :

```
n1 = p1*q1
n2 = p2*q2 = (p1+x)*(q2+y) # với x,y là số nhỏ
```

Do khoảng cách giữa p1 và p2 cũng như q1 và q2 là nhỏ thì ta có thể sử dụng `Fermat’s attack`

Nhưng nếu Fermat attack n1 hoặc n2 thì sẽ không ra tại vì p1,q1 hoặc p2,q2 đâu có gần nhau. 
Vậy nên ta sử dụng Fermat atack trên (n1*n2)

Sau khi xin hint chị Uyên thì mình đi lục wu và thấy bài https://ce-automne.github.io/2019/07/05/ISITDTU-CTF-2019-WriteUp-Part2/ là tương tự nên lấy xài thôi 

```python
import gmpy2

n1 = 225612891097924040706347292537924529130748697814598650779790890321296957687477717412569695768328009713449975967009666897728739592058804927345594604661797805798320309214169550517668137208475071843904537882299585482167565038513108310939720805780339304461071553690155483189411217623168658653984297513568691227493489702035504043460939913284986540798077821986163959026623386252138611094363377701124961846800926711310486987945165331076229592211876939859375144018490447856489757527762378389911481207939664436804078899938906828688591523398747363597695298879921379961097878550014680021403378423799905308848809120405798176353
e1 = 65537
n2 = 225612891097924040706347292537924529130748697814598650779790890321296957687477717412569695768328009713449975967009666897728739592058804927345594604661797805798320309214169550517668137208475071843904537882299585482167565038513108310939720805780339304461071553690155483189411217623168658653984297513568691265159755148954191405071460410083629205595133967069224978599563580256703745535232222292964323590835562142793789416686915496149547981084080783125615742881408395079922620337849148727507795907992405112121391961462894493213328428737417795782345238338628066525116106657456509258570760259889666093973978173599855723931
e2 = 65537

def fermat_factorization(n):
    factor_list = []
    gmpy2.get_context().precision = 2048
    a = int(gmpy2.sqrt(n))

    a2 = a * a
    b2 = gmpy2.sub(a2, n)

    while True:
        a += 1
        b2 = a * a - n

        if gmpy2.is_square(b2):
            b2 = gmpy2.mpz(b2)
            gmpy2.get_context().precision = 2048
            b = int(gmpy2.sqrt(b2))
            factor_list.append([a + b, a - b])

        if len(factor_list) == 2:
            break

    return factor_list


fermat_list = fermat_factorization(n1*n2)
print(fermat_list)
```

Sau khi chạy tool thì nó trả về tất cả các trường hợp : `p1*q1`, `p1*q2`, `p2*q1`, `p2*q2`
Việc của mình giờ tìm GCD là tìm được p or q rồi !

```python
import math

from Crypto.Util.number import *
import gmpy2

n1 = 225612891097924040706347292537924529130748697814598650779790890321296957687477717412569695768328009713449975967009666897728739592058804927345594604661797805798320309214169550517668137208475071843904537882299585482167565038513108310939720805780339304461071553690155483189411217623168658653984297513568691227493489702035504043460939913284986540798077821986163959026623386252138611094363377701124961846800926711310486987945165331076229592211876939859375144018490447856489757527762378389911481207939664436804078899938906828688591523398747363597695298879921379961097878550014680021403378423799905308848809120405798176353
e1 = 65537
n2 = 225612891097924040706347292537924529130748697814598650779790890321296957687477717412569695768328009713449975967009666897728739592058804927345594604661797805798320309214169550517668137208475071843904537882299585482167565038513108310939720805780339304461071553690155483189411217623168658653984297513568691265159755148954191405071460410083629205595133967069224978599563580256703745535232222292964323590835562142793789416686915496149547981084080783125615742881408395079922620337849148727507795907992405112121391961462894493213328428737417795782345238338628066525116106657456509258570760259889666093973978173599855723931
e2 = 65537

def fermat_factorization(n):
    factor_list = []
    gmpy2.get_context().precision = 2048
    a = int(gmpy2.sqrt(n))

    a2 = a * a
    b2 = gmpy2.sub(a2, n)

    while True:
        a += 1
        b2 = a * a - n

        if gmpy2.is_square(b2):
            b2 = gmpy2.mpz(b2)
            gmpy2.get_context().precision = 2048
            b = int(gmpy2.sqrt(b2))
            factor_list.append([a + b, a - b])

        if len(factor_list) == 2:
            break

    return factor_list


factor_list = fermat_factorization(n1*n2)
[X1, Y1] = factor_list[0]
[X2, Y2] = factor_list[1]

n1 = 225612891097924040706347292537924529130748697814598650779790890321296957687477717412569695768328009713449975967009666897728739592058804927345594604661797805798320309214169550517668137208475071843904537882299585482167565038513108310939720805780339304461071553690155483189411217623168658653984297513568691227493489702035504043460939913284986540798077821986163959026623386252138611094363377701124961846800926711310486987945165331076229592211876939859375144018490447856489757527762378389911481207939664436804078899938906828688591523398747363597695298879921379961097878550014680021403378423799905308848809120405798176353
p1 = math.gcd(n1,X1)
q1 = n1//p1
e1 = 65537
c1 = bytes_to_long(open('./stage3/flag.txt.key1.enc',"rb").read())
phi = (p1-1)*(q1-1)
d1 = inverse(e1,phi)
M = pow(c1,d1,n1)

print(long_to_bytes(M))
#b'and_this_is_just_some_random_string_to_make_the_flag_long_enough_308c8dfa144c4f41c3dfa06b5}'
```

FLAG : `TSJ{just_several_common_rsa_tricks_combined_together_in_a_single_guessy(?)_challenge_and_this_is_just_some_random_string_to_make_the_flag_long_enough_308c8dfa144c4f41c3dfa06b5}`

# RNG++

Source Chall

```python
from Crypto.Util.number import *
flag = b"TSJ{aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}"

assert flag.startswith(b"TSJ{")
assert flag.endswith(b"}")
flag = flag[4:-1]


class RNG:
    def __init__(self, sz: int):
        self.M = 2 ** sz
        self.A = getPrime(sz)
        self.C = getPrime(sz)
        self.S = getRandomRange(1, self.M)

    def encrypt(self, m: bytes):
        self.S = (self.A * self.S + self.C) % self.M
        print(f'self.S = {self.S}')
        return long_to_bytes(bytes_to_long(m) ^ self.S)

    def __repr__(self):
        return f"{self.M} {self.A} {self.C}"


def randmsg(sz: int):
    return str(getRandomRange(1, 2 ** sz)).encode()[: sz // 8]

rng = RNG(len(flag) * 8)
print(rng)

msgs = [flag] + [randmsg(len(flag) * 8) for _ in range(4)]

for m in msgs:
    print(rng.encrypt(m).hex())
```

